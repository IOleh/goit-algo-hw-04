# goit-algo-hw-04
### Висновки щодо ефективності алгоритмів сортування

У цьому домашньому завданні (у файлі Sort_TimeIt.py) було протестовано три алгоритми сортування: сортування злиттям (Merge Sort), сортування вставками (Insertion Sort) і Timsort (вбудований в Python).

#### Результати:
набори даних (масиви) були згенеровані за допомогою модуля random у Python. Один із запусків програми видав наступні результати:
- **Merge Sort**: 0.226 секунд
- **Insertion Sort**: 2.023 секунд
- **Timsort (built-in)**: 0.007 секунд

#### Аналіз:

1. **Merge Sort** працює теоритично за \(O(n \log n)\). Цей алгоритм показав досить ефективний результат (0.226 секунд), значно швидший за сортування вставками, що підтверджує його кращу масштабованість. Merge Sort є стабільним та ефективним для великих наборів даних, особливо коли дані не частково відсортовані.
2. **Insertion Sort** був найповільнішим (2.023 секунд), через складність \(O(n^2)\). Це очікуваний результат для цього методу, оскільки сортування вставками ефективне лише для малих або частково відсортованих масивів, але має погану масштабованість для великих наборів випадкових даних. Через квадратичну складність цей алгоритм не підходить для великих обсягів даних. Він підходить тільки для малих або вже частково відсортованих масивів.
3. **Timsort** виявився найшвидшим (0.007 секунд) завдяки поєднанню сортування злиттям і вставками, що робить його дуже ефективним для різних типів даних.

#### Висновок:

Timsort — найкращий вибір для сортування, оскільки він швидкий і підходить для більшості задач. Це пояснює, чому Python використовує цей алгоритм для вбудованих функцій сортування, а не інші методи.